#+title: CS158B Spring 2024 Project
#+author: Cesar Rocha 015127099
#+OPTIONS: ^:nil

* Assumptions

** Python

This Python[fn:3] project was developed using NixOS[fn:1]. Appendix [[=shell.nix=]] contains the =shell.nix= file for this app. However, a non-NixOS user can use Python's pip [fn:2] and =requirements.txt= (Figure [[fig:requirements]]) to run it.

#+name: fig:requirements
#+caption: The =requirements.txt= file
#+begin_src
black==24.4.0
blinker==1.7.0
click==8.1.7
Flask==3.0.3
itsdangerous==2.2.0
Jinja2==3.1.3
MarkupSafe==2.1.5
mypy-extensions==1.0.0
packaging==24.0
pathspec==0.12.1
ping3==4.0.8
platformdirs==4.2.1
prometheus_client==0.20.0
psutil==5.9.8
tomli==2.0.1
typing_extensions==4.11.0
Werkzeug==3.0.2
#+end_src

#+caption: Install requirements through pip (Virtual Environment recommended)
#+begin_src
pip install -r requirements.txt
#+end_src

** Prometheus

The next assumption is that you have a way to run prometheus [fn:4]. The =prometheus.yml= file has been provided (Figure [[fig:prometheus-yaml-file]]) and so are the instructions to run it (Figure [[fig:prometheus-command]])

#+name: fig:prometheus-yaml-file
#+caption: The =prometheus.yml= file
#+begin_src
global:
  scrape_interval:     10s # By default, scrape targets every 15 seconds.


# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=<job_name>` to any
  # timeseries scraped from this config.
  - job_name: 'cs-158b-project'

    # Override the global default and scrape targets from this job
    # every 5 seconds.
    # scrape_interval: 5s
    static_configs:
      - targets: [ 'localhost:5000']
#+end_src

#+name: fig:prometheus-command
#+caption: This command starts the Prometheus monitoring server using the specified configuration file =prometheus.yml=.
#+begin_src
prometheus --config.file=prometheus.yml
#+end_src

#+begin_src latex
\newpage
#+end_src


* Design

** Average Ping RTT(=avg_rtt=)
*** Ping3

Average Ping RTT was calculated using ping3 [fn:5] library's =ping= function in python

#+caption: Pinging "google.com" which is something that exists
#+begin_src python :exports both :results table
from ping3 import ping

return f"Ping something that exists: {ping('google.com', unit='ms')}"
#+end_src

#+caption: result from pinging "www.google.com"
#+RESULTS:
: Ping something that exists: 58.66885185241699

#+caption: Pinging something that doesn't exist ('www.netflix.com')
#+begin_src python :exports both :results table
from ping3 import ping

return f"Ping something that does not exist: {ping('www.netflix.com')}"
#+end_src

#+caption: Python output from something that does not exist
#+RESULTS:
| Ping something that does not exist: None |

To collect these pings, we want to collect create an iterable to pass to =statistics.mean=. A =ping_host= function that contains an iterator that returns the next valid ping was used to generate the dataset in combination with =islice= to take at most 5 pings.

#+caption: collecting five pings
#+begin_src python :exports table
from ping3 import ping
from itertools import islice
number_of_pings = 5

def ping_host(host: str):
    return iter(lambda: ping(host, unit="ms", timeout=2), None)

return list(islice(ping_host("google.com"), number_of_pings))
#+end_src

#+RESULTS:
| 58.83932113647461 | 58.669090270996094 | 57.837486267089844 | 57.84034729003906 | 57.858943939208984 |

Timeout is useful for when the ping takes too long, or host doesn't exist. The =None= argument in the =iter= tells it to leave when the ping is invalid, only generating a valid dataset that can be passed to =statistics.mean=.

#+caption: collecting five pings for something that doesn't exist returns an empty list
#+begin_src python :exports both
from ping3 import ping
from itertools import islice
number_of_pings = 5

def ping_host(host: str):
    return iter(lambda: ping(host, unit="ms", timeout=2), None)

return list(islice(ping_host("netflix.com"), number_of_pings))
#+end_src

#+caption: empty list for pinging something that doesn't exist
#+RESULTS:

*** =app.py=

To record the ping results in =app.py=, A =Gauge= that keeps track of pings, and a list of hosts to ping was created.

#+caption: gauge to keep track of the ping results and lists of hosts to ping in =app.py=
#+begin_src
# Set up a gauge to track the ping results
ping_gauge = Gauge(
    "avg_rtt",
    "Ping time to specific hosts",
    ["dest"],
)

# List of hosts to ping
hosts_to_ping = [
    "192.168.1.1",
    "www.google.com",
    "www.netflix.com",
    "www.cnn.com",
]
#+end_src

#+name: fig:mean_pings
#+caption: =update_ping_guage= function in =app.py=
#+begin_src
def update_ping_gauge():
    """Define a function to update the gauge with ping results"""
    number_of_pings = 5
    for host in hosts_to_ping:
        # creates an iterator of pings to host that stops at `None`
        def ping_host(host: str):
            return iter(lambda: ping(host, unit="ms", timeout=2), None)

        # takes at most `number_of_pings` rtt from ping_host
        take_n_pings = list(islice(ping_host(host), number_of_pings))
        # takes the mean of the list of valid ping times 0 for invalid pings
        ping_gauge.labels(dest=host).set(
            statistics.mean(take_n_pings if take_n_pings else [0])
        )
#+end_src


See Figure [[fig:mean_pings]] for the implementation of the updated gauge in =app.py=. Figure [[fig:metrics]] shows how the =update_ping_gauge= function is used in =app.py= to collect information about =avg_rtt= for scraping.

#+name: fig:metrics
#+caption: =app.py=. Flask =/metrics= function where =update_ping_gauge= is used.
#+begin_src
@app.route("/metrics", methods=["GET"])
def get_data():
    """Returns all data as plaintext."""
    number_of_requests.inc()
    current_memory_usage.labels("server-a").set(random.randint(10000, 90000))
    update_ping_gauge()
    update_packets_by_interface()
    return Response(generate_latest(), mimetype=CONTENT_TYPE_LATEST)
#+end_src

*** Results

#+caption: prometheus scraping localhost:9090 for =avg_rtt=. Unreachable destinations are marked as $0$
[[file:~/2024-04-28-172352_1597x764_scrot.png]]

#+caption: prometheus scraping localhost:9090 for =avg_rtt= of "www.google.com"
[[file:~/2024-04-28-172245_1592x829_scrot.png]]

#+begin_src latex
\newpage
#+end_src

** Number of Packets Sent(=packets_sent=)
*** psutils

The psutil[fn:6] library can be used to monitor the number of packets sent by interface. The net_io_counters [fn:7] method returns network I/O statistics as a named tuple. Using the =pernic=True= variable will return that named tuple for all network interface names.

#+caption: Looking up packets sent for network interface =lo= using =psutil=
#+begin_src python :exports both :results table
import psutil

return psutil.net_io_counters(pernic=True)['lo'].packets_sent
#+end_src

#+caption: results of looking up interface =lo= using =psutil= to find packets sent
#+RESULTS:
| 207727 |
*** =app.py=

A packets sent gauge was created to keep track of packets sent per network interface

#+caption: =packet_set_gauge= in =app.py=
#+begin_src
# Create a Gauge metric to hold the packets sent by each network interface
packet_sent_gauge = Gauge(
    "packets_sent",
    "Packets sent by each network interface",
    ["ifname"],
)
#+end_src

To fill in the packet sent gauge, a function named =update_packets_by_interface= function was created to loop through all network interfaces in =psutil.net_io_counters(pernic=True)= and collect the packets sent.

#+name: fig:packets_sent
#+caption: =update_packets_by_interface()= in =app.py=
#+begin_src
def update_packets_by_interface():
    net_io_counters = psutil.net_io_counters(pernic=True)

    # Update the metric with the latest packets sent count for each interface
    for interface, counters in net_io_counters.items():
        packet_sent_gauge.labels(ifname=interface).set(
            counters.packets_sent,
        )
#+end_src

The =update_packets_sent_by_interface= function was used in =app.py= in the =get_data= function (Figure [[fig:metrics]]).


*** Results

#+caption: prometheus query for =packets_sent= in localhost:9090 scraping localhost:5000
[[file:~/2024-04-28-184957_1599x841_scrot.png]]


#+caption: prometheus query for =packets_sent= for =ifname=lo= in localhost:9090 scraping localhost:5000
[[file:~/2024-04-28-185252_1596x542_scrot.png]]

#+begin_src latex
\newpage
#+end_src

** Number of Packets Received(=packets_recv=)

*** psutil

To obtain the number of packets received per network interface,


#+caption: Looking up packets received for network interface =lo= using =psutil=
#+begin_src python :exports both :results table
import psutil

return psutil.net_io_counters(pernic=True)['lo'].packets_recv
#+end_src

#+caption: results of looking up interface =lo= using =psutil= to find packets received
#+RESULTS:
| 207797 |

*** =app.py=

To collect the packets received per network interface, a packets received gauge was created

#+caption: =packets_received_gauge= in =app.py=
#+begin_src

# Create a Gauge metric to hold the packets sent by each network interface
packet_received_gauge = Gauge(
    "packets_recv",
    "Packets received by each network interface",
    ["ifname"],
)
#+end_src


#+caption: using the =packets_received_gauge= to collect =packets_recv= for every network interface in =update_packets_by_interface= in =app.py=
#+begin_src
def update_packets_by_interface():
    net_io_counters = psutil.net_io_counters(pernic=True)

    # Update the metric with the latest packets sent count for each interface
    for interface, counters in net_io_counters.items():
        packet_sent_gauge.labels(ifname=interface).set(
            counters.packets_sent,
        )
        packet_received_gauge.labels(ifname=interface).set(
            counters.packets_recv,
        )
#+end_src

*** Results

#+caption: prometheus query for =packets_recv= in localhost:9090 scraping localhost:5000
[[file:~/2024-04-28-190104_1599x832_scrot.png]]


#+caption: prometheus query for =packets_recv= in localhost:9090 scraping localhost:5000
[[file:~/2024-04-28-190257_1600x521_scrot.png]]

#+begin_src latex
\newpage
#+end_src

#+LaTeX: \appendix

* =app.py=

#+begin_src
"""
Network Monitoring with Prometheus

Module sets up an HTTP server to expose prometheus metrics for monitoring
network traffic on a system. It collects statistics for each network
interface using the 'psutil' and 'ping3' libraries and updates Prometheus
metrics with the average rtt, count of packets sent and received

Metrics:
- `avg_rtt`: avg_rtt to dest
- `packets_sent`: Number of packets sent by each network interface.
- `packets_received`: Number of packets received by each network interface.
"""
import random
import logging
import statistics
from flask import Flask, Response
from prometheus_client import Counter, Gauge, generate_latest
from ping3 import ping
import psutil


# Create a Prometheus Gauge to represent a custom metric
custom_gauge = Gauge(
    "custom_metric",
    "A custom metric based on a parameter",
)

logger = logging.getLogger(__name__)
app = Flask(__name__)
CONTENT_TYPE_LATEST = str("text/plain; version=0.0.4; charset=utf-8")

number_of_requests = Counter(
    "number_of_requests",
    "The number of requests, its a counter so the value can increase or reset to zero.",
)

current_memory_usage = Gauge(
    "current_memory_usage_locally",
    "The current value of memory usage, its a gauge so it can go up or down.",
    ["server_name"],
)

# Set up a gauge to track the ping results
ping_gauge = Gauge(
    "avg_rtt",
    "Ping time to specific hosts",
    ["dest"],
)

# List of hosts to ping
hosts_to_ping = [
    "192.168.1.1",
    "www.google.com",
    "www.netflix.com",
    "www.cnn.com",
]

# Create a Gauge metric to hold the packets sent by each network interface
packet_sent_gauge = Gauge(
    "packets_sent",
    "Packets sent by each network interface",
    ["ifname"],
)

# Create a Gauge metric to hold the packets sent by each network interface
packet_received_gauge = Gauge(
    "packets_recv",
    "Packets received by each network interface",
    ["ifname"],
)


def update_ping_gauge():
    """Define a function to update the gauge with ping results"""
    number_of_pings = 5
    for host in hosts_to_ping:
        ping_times = []
        for _ in range(number_of_pings):
            rtt = ping(host, unit="ms")
            if not rtt:
                # spending too long on timeout or non existing pings
                # wastes time and energy.
                ping_times.append(0)
                break
            ping_times.append(rtt)
        # Take a mean of the list of five pings
        ping_gauge.labels(dest=host).set(statistics.mean(ping_times))


def update_packets_by_interface():
    """
    Define a function that collects the packets sent and received by each
    network interface
    """
    net_io_counters = psutil.net_io_counters(pernic=True)
    # Update the metric with the latest packets sent count for each interface
    for interface, counters in net_io_counters.items():
        packet_sent_gauge.labels(ifname=interface).set(
            counters.packets_sent,
        )
        packet_received_gauge.labels(ifname=interface).set(
            counters.packets_recv,
        )


@app.route("/metrics", methods=["GET"])
def get_data():
    """Returns all data as plaintext."""
    number_of_requests.inc()
    current_memory_usage.labels("server-a").set(random.randint(10000, 90000))
    update_ping_gauge()
    update_packets_by_interface()
    return Response(generate_latest(), mimetype=CONTENT_TYPE_LATEST)


if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0")
#+end_src

#+begin_src latex
\newpage
#+end_src

* =shell.nix=

#+begin_src
{ pkgs ? import <nixpkgs> { } }:

let
  # Overriding the default 'ping3' package with custom source details
  customPing3 = pkgs.python3Packages.buildPythonPackage rec {
    pname = "ping3";
    version = "4.0.8";
    format = "wheel";

    src = pkgs.fetchurl {
      url = "https://files.pythonhosted.org/packages/e6/f4/4070daca3da5bbc"
        + "3ef5e622d68f979e034e5bf678416817918e51a1b2907/"
        + "ping3-4.0.8-py3-none-any.whl";
      sha256 = "152mj8qrqhbphrm46jsr451bh714g0kjb7gnkag25d38362r9hmm";
    };
    # Disable tests, as they might not be needed for this context
    doCheck = false;
  };

  # Create a Python environment with additional packages,
  # including the custom 'ping3'
  myPythonEnv = pkgs.python3.withPackages (ps: with ps; [ customPing3 ]);

in pkgs.mkShell {
  # The build inputs for the Nix shell include the
  # Python environment with customizations
  buildInputs = [
    # installing ping3
    myPythonEnv
    # installing prometheus
    pkgs.prometheus
    # installing pyton packages from nixpkgs
    (with pkgs.python3Packages; [
      pylint
      black
      flask
      psutil
      jinja2
      prometheus-client
    ])
    # installing LaTeX for report writing
    (pkgs.texlive.combine {
      inherit (pkgs.texlive)
        scheme-full beamer latexmk wrapfig ulem capt-of
        collection-fontsrecommended amsmath hyperref;
    })
  ];
}
#+end_src

* Footnotes

[fn:7] net_iocounters. https://psutil.readthedocs.io/en/latest/#psutil.net_io_counters
[fn:6] psutil. https://pypi.org/project/psutil/
[fn:5] Ping3. https://pypi.org/project/ping3/
[fn:4] Prometheus. [[https://prometheus.io/]]

[fn:3] Python. https://www.python.org/
[fn:2] Pip. https://pip.pypa.io/en/stable/installation/
[fn:1] NixOS. https://nixos.org/
